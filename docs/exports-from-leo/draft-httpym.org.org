# Created 2025-11-28 vie 19:48
#+OPTIONS: num:t H:10 ^:{}
#+OPTIONS: html5-fancy:t
#+TITLE: HTTPico: Shrinking HTTP architecture into Eiffel (an AOP implementation)
#+DATE: <17 November 2025>
#+AUTHOR: Alejandro Garcia
#+language: en
#+bibliography: references.bib
#+html_head: <link rel="stylesheet" href="https://unpkg.com/latex.css/style.min.css" />
#+html_doctype: html5
#+html_mathjax: yes
#+macro: impnote <<imp$1-destination>> [[imp$1-origin][↩ $1]]
#+macro: impmark <<imp$1-origin>>^{[[imp$1-destination][obs:$1]]}


* Abstract

The HTTP protocol has given the Web its scalability and composability properties.
In Architecture Oriented Programming (AOP),
Marcel P. Weiher had the insight that we could scale down the architecture of the web:
Its fundamental mechanisms: URLs and HTTP methods,
to provide uniform access across resources and a common interface to connect them.
We present HTTPico, an Eiffel library that implements AOP based on Weiher’s ideas and the HTTP specification.

#+name: HTTPico_one_sentence_summary
#+begin_verse
HTTPico shrinks HTTP’s core architectural mechanisms:
URIs, uniform methods, and status codes into
composable classes for a single Eiffel program.
#+end_verse

Eiffel is ideal to express AOP ideas,
because of the principles such as Uniform Access Principle (UAP),
Multiple Inheritance and Design by Contract (DbC).

We describe the design of HTTPico.
It's implementation and examples o its use.
Including clients for =http://=, =file://=, and =env://= schemes.
And compare the resulting Eiffel code with equivalent idioms in other programming languages.

* Introduction

Modularity and composition  remain open problems.
Ever since Parnas' classic paper on decomposition [cite:@ParnasDecomposition]
through 90s with object-oriented programming an the 2010's with functional programing,
and to this day with Jackson’s Concept-Oriented Design [cite:@Jackson2024],
we are still striving for better modularity and composition.

Following Parnas, we view modularity primarily as a question of how changes are localized:
/when we change X, how many other parts must change with it?/
Meyer [cite:@OOSC, pp.39--65} refines this intuition by treating modularity as a property of a design method,
measured against five criteria: decomposability, composability, understandability, continuity, and protection.

In particular, modular composability means that the method encourages software elements that can be freely recombined to build new systems.
Modularity and composition are opposing forces:
modules want to be as independent as possible so that changing them doesn't affect the rest of the system,
But compositions need components to be interdependent to have more powerful behaivours.

However we have model of Modularity and Composability that works and is in use everyday by billions of users:
the World Wide Web.
On the Web, each /resource/ (a web page, a PHP script or a printer) is independent from the others.
Yet we can create new applications by combining them, and we can interpose many components without breaking the model.
From the most basic interaction: A browser and a server, exchanging an about page.
To a complex one, with local proxys, caches and load balancers.
Every one of the components could change, and yet the system continues to function.
Compare this to what happens with mainstream programming languages:

- Accessing heterogeneous resources (files, env vars, web APIs) is hard; every resource has its own mini-protocol.
- Composing heterogeneous components is a manual process and unique for each pair of components you want to integrate.
- Changing one component of a composition is very difficult, because each compostion is tightly coupled.
Weiher’s Architecture Oriented Programming asks:
What would happen if we shrink HTTP’s uniform interface to the level of a single process?
An "In-Process REST" [cite:@Weiher2014] if you will.

AOP brings into a single program the kind of composability that the Web already enjoys.
By “shrinking” the Web’s architecture: URLs as polymorphic identifiers, and a small uniform interface of HTTP methods inside a process,
he turns resources and stores into components that can be freely composed and recomposed.
In this paper we implement HTTPym an AOP library for Eiffel.
It uses Eiffel’s Uniform Access Principle, Design by Contract and Multiple Inheritance to realize Weiher’s in-process REST style [cite:WeiherInProcessRest] and Polymorphic Identifiers [cite:WeiherPolymorphicIdentfiers].

Our contributions are:

- A design of an HTTP-inspired protocol in Eiffel (HTTPico).
- A library of scheme clients for env://, file://, http:// based on URLs (Weiher's Polymorphic identifiers).
- A mapping from HTTP semantics to Eiffel’s Design by Contract (e.g. 404, 500, 501 as contract violations).
- A case study or examples showing uniform access.

The rest of the paper is structured as follows:

Section 2 presents motivating examples.
Section 3 summarizes the necessary HTTP and AOP background.
Section 4 presents the design of HTTPico.
Section 5 its implementation.
Section 6 presents a small evaluation based on a TODO example.
Section 7 discusses lessons learned, limitations, and future work.
Section 8 compares against related work.
Section 9 concludes.
* Motivating Examples
Let's not bury the lead here.
And show how HTTPico allows the composition of components that weren't made to be togother.


SCHEME_HANDLERS  are the classes that know how to communicate to remote and local resources (aka services, processes) and intra services.

Since they abstract the external world to expose it inside our program they are messy by definition.
BUT the iterface they expose inside the program is clean and predictiable.
SCHEME_HANDLERS  are the classes that know how to communicate to remote and local resources (aka services, processes) and intra services.

Since they abstract the external world to expose it inside our program they are messy by definition.
BUT the iterface they expose inside the program is clean and predictiable.


#+begin_src eiffel
local
 l_file: FILE
 l_env: ENV
 l_http: HTTP
 l_schema:SCHEMA_HANDLER
do
 create l_env
 create l_file
 create l_http
end
#+end_src

The way to use them is:

#+begin_src Eiffel
print(l_env["hostname"])  -- lets get the name of the current computer executing the file.

l_file["an_example_file.txt"] := "this is writing to  a new file" -- this synta

content_of_file := l_http["http://www.example.com/about.html"] -- this is doing a get

print(content_of_file)

l_schema["file:my_current_file.txt"] -- this generate a file schema_handler and does the put
#+end_src

Goning further, to read the contents of a website in a local server


a website remotely we can use:

#+begin_src Eiffel
http_client: SCHEME_CLIENT = "http://www.example.com/"
print(http_client["/about"])
#+end_src

Or perhaps we want te read a website in a local web server

#+begin_src Eiffel
http_client: SCHEME_CLIENT = "http://localhost/"
print(http_client["/about"])
#+end_src

The usability of URLs is more manifest when we use different schemas like "file" or "ftp".


#+begin_src Eiffel
file_reader : SCHEME_CLIENT = "file:///home/username/about.txt"
#+end_src

Even environment variables with a pseudo-scheme `env`


#+begin_example
local_variabels : SCHEME_CLIENT = "env://"
#+end_example

It is important to know that each schema (http, file, env, etc.) require their own {SCHEMA_HANDLER} that understands each protocol, but exposes the communication through a uniform interface.

The uniform interface is inspired by HTTP methods, and we go into a lot more detail and justification in our next paper.
about the HTTPico library.

For now suffice to say that all the SCHEME_CLIENTS expose the same interface, i.e. features.
<<<<<<< variant A
>>>>>>> variant B

======= end
** Example TODOMVC
TODOMVC is an example todo-list.
Ipmlemented in multiple frontend frameworks so that developers can compare their implementations.
All the different versions of the frontend work with the same API Backend.

@todo Insert a screenshot of todomvc.

The complement is TODOBACKEND were multiple backend frameworks are developed to expose the same Web Api.
So that different front ends can connect to i.

Now we need to asks ourselves:





*** How difficult should a client like TODOMVC be?
*** How difficult a TODOBACKEND should be?
Now we asks ourselves the opposito question.

How hard could it be to create a backend implementation of a TODO list?

Well in HTTPico is like this:

*** How can we make a local first TODOLIST?
Now let's go beyond the traditional TODOMVC

And reflect how could we create local todo-mvc
that doesn't go to the internet everytimme
we want to read the mvc.

So that we want to cache the data locally.
and keep our local and remote copies sync.
I don't know about you.
But that looks pretty small to me.

If you want to see how to achieve such brevity.
Follow a long to learn about HTTPico and Weihers StorageCombinators and how Eiffel makes it possible.

Just preamble the same command line client in C# is

@askchatgpt make a client in C# for the code


And in Java like this.


In Javascrip which is asymptotic because JSON
is it's native datatype

@askchatgpt make comparable client in javascript to connect to from the commandline


* Background

** HTTP and the REST architectural style

HTTP is the application-level protocol of the World Wide Web,
standardized by the IETF and W3C and refined over decades of browser and server practice [cite:@FieldingsThesis;@mozilla_http_overview].
It defines how clients and servers exchange messages to manipulate *resources* identified by *Uniform Resource Identifiers* (URIs).

For HTTPico we are not interested in every detail of HTTP,
but in a small set of architectural ideas:

- *Resources and URIs* :: HTTP operates on abstract resources (documents, images, services, data collections…).
     Each resource is identified by a URI;
     the bytes sent over the wire (HTML, JSON, images) are *representations* of its state.
- *Uniform methods* :: A small, fixed vocabulary of methods (e.g., =GET=, =HEAD=, =PUT=, =DELETE=, =POST=, =PATCH=)
     is used for all resources.
     Methods are classified as safe vs. unsafe and idempotent vs. non-idempotent,
     which constrains how clients may use them.
- *Status codes as outcome vocabulary* :: Responses carry a status line (e.g., 200 OK, 404 Not Found, 500 Internal Server Error).
     Codes are grouped into families (1xx informational, 2xx success, 3xx redirection, 4xx client error, 5xx server error)
     and serve as a compact language of *outcomes* for the request.
- *Intermediaries* :: Proxies, gateways, and caches can be placed between user agents and origin servers.
     They forward or transform messages while preserving the same method/URI/status vocabulary.

A simple HTTP interaction consists of a user agent (browser) sending a request (method, URI, headers, optional body) to an origin server,
which replies with a status code, headers, and an optional body:

#+name: fig:basic-web-interaction
#+caption: Simple HTTP interaction between user agent and origin server.
[[file:basic-web-interaction.svg]]

A key strength of HTTP is how easily components can be *composed*.
Intermediaries such as reverse proxies, caches, gateways, and logging filters
can be chained between client and server without changing the basic interaction model:
each intermediary still receives a request and produces (or forwards)
a response using the same uniform vocabulary.

Because the protocol is message-based and the interface is uniform,
these intermediaries can remain largely *transparent*:
clients need not know how many or which components sit between them and the origin.
yet concerns such as caching, logging, load balancing or access control can be inserted or rearranged without breaking the system.

#+name: fig:complex-web-interaction
#+caption: HTTP interaction with intermediaries (cache and reverse proxy) inserted transparently.
[[file:complex-web-interaction.svg]]

Viewed this way, the HTTP specification reads like a catalogue of *contracts* between clients, servers, and intermediaries:
which methods are allowed, under what preconditions, and how various outcomes are expressed as status codes and headers.
HTTPico reuses this architectural vocabulary: URIs, methods, and status codes;
but applies it *inside* a program rather than across the network.

** Architecture-Oriented Programming and In-Process REST

Alan Kay famously described Smalltalk objects as being

#+begin_quote
“a bit like having thousands and thousands of computers all hooked together by a very fast network.” [cite:@Kayearlyhistory]
#+end_quote

At the time, such networks did not exist.
Kay had to *imagine* what communication between thousands of computers might look like.
Today we do have such a network, on a planetary scale, and it does not speak Smalltalk messages.
It speaks HTTP.

Marcel P. Weiher’s *Architecture-Oriented Programming* (AOP) starts from this observation:
instead of inventing yet another object-message protocol and hoping it scales,
we can “scale down” the architecture that already scales up,
namely the Web’s HTTP/REST architectural style [cite:@WeiherInProcessRest].

The idea is to take the core mechanisms of the Web:

- URIs as a uniform reference mechanism,
- HTTP methods as a uniform interface,
- and intermediaries (proxies, gateways, caches) as composable connectors,

and apply them *inside* a single process.

Weiher proposes three closely related concepts that we build on in HTTPico:

- Polymorphic Identifiers :: URI-like references used *inside* the program to name heterogeneous resources uniformly
     (variables, files, environment variables, remote services…).
- In-Process REST :: A storage protocol with operations mirroring HTTP methods
     (get, put, merge, delete) defined on these references,
     but implemented as method calls instead of network messages.
- Storage Combinators :: Composable “intermediary” stores (caches, loggers, switches, mappers, etc.)
     that sit between clients and base stores,
     analogous to HTTP proxies and gateways [cite:@WeiherStorageCombinators].

Together, these three elements shrink HTTP’s uniform interface into an in-process abstraction:
URIs become polymorphic identifiers;
HTTP methods become storage operations;
proxies and gateways become storage combinators.

*** Polymorphic identifiers

In Objective-S, Weiher’s language for experimenting with these ideas, *polymorphic identifiers* are the in-process counterpart of URLs: a single notation for referring to values, fields, files, or remote resources [cite:WeiherPolymorphicIdentifiers]. They extend Eiffel’s Uniform Access Principle from “features of an object” to “resources of an entire program”.

For example, the following are all valid polymorphic identifiers:

#+name: Listing:ValidPolymorphicIdentifiersInObjectiveSmalltalk
#+caption: Valid polymorphic identifiers in Objective-Smalltalk, after Weiher [cite:WeiherPolymorphicIdentifiers].
#+begin_src
person
name
var:person/name
var:person/{attribute}
file://tmp/button.png
http://www.example.com/button.png
file:{env:HOME}/rfcs/{rfcName}
#+end_src

Some of these look like simple variable names (=person=, =name=); others look like URLs (=file://…=, =http://…=); others embed environment variables or parameters. The important point is that *all* of them denote resources through the *same* interface. Clients need not know in advance whether a reference points to a field, an in-memory table, a file on disk, or a remote HTTP resource.

HTTPico adopts this idea for Eiffel: URIs (and URI-like strings) become polymorphic identifiers that can denote both external resources (e.g., =http://…=, =file://…=) and internal ones (e.g., =env://VAR= or in-program tables).

*** In-Process REST: a storage protocol

If polymorphic identifiers are the in-process counterpart of URIs, then an *in-process REST* protocol is the counterpart of HTTP methods and status codes. Instead of sending =GET= or =PUT= across the network, a client calls operations on a *store* object that accepts polymorphic identifiers as keys.

In Objective-S this is expressed as a small protocol:

#+name: lst:store-protocol
#+caption: Storage protocol expressed in Objective-Smalltalk (after Weiher).
#+begin_src objective-c
protocol Storage {
  -at: ref;
  -<void> at: ref put: object;
  -<void> at: ref merge: object;
  -<void> deleteAt: ref;
}
#+end_src

The =at:= operation retrieves the value associated with a reference (a =GET=). The =put:= operation overwrites state (a =PUT=); =merge:= refines or updates it (similar in spirit to =PATCH=); =deleteAt:= removes it (a =DELETE=). Implementations are free to back these operations with in-memory tables, files, databases, or remote calls.

HTTPico mirrors this protocol in Eiffel: stores implement a small, HTTP-inspired interface for manipulating resources inside the program, using polymorphic identifiers as keys.

*** Storage combinators

On the Web, much of HTTP’s power comes from *intermediaries*: caches, reverse proxies, gateways, logging filters, authentication and compression layers that can be inserted in the request/response path without changing client or server code. Weiher’s storage combinators are the in-process analogue of these intermediaries [cite:@WeiherStorageCombinators].

A *storage combinator* is a store that wraps another store (or several stores), adding cross-cutting behavior:

- a cache combinator may satisfy =get= from a local cache and only delegate misses to a slower underlying store;
- a logging combinator may record every access;
- a mapping combinator may transform keys or values;
- a switching combinator may route some references to one store and others to another.

Because all stores implement the same small protocol, combinators can be freely composed, much like HTTP proxies and gateways. HTTPico adopts this approach directly: Eiffel classes implement a uniform store interface, and storage combinator classes (cache, logger, switch, etc.) wrap other stores, giving HTTP-like composability inside a single program.

** Eiffel Programming Principles

Eiffel’s design is built around a small set of principles that make object-oriented software more modular, explicit, and verifiable [cite:@OOSC]. Among these, five are particularly relevant for HTTPico:

- Design by Contract (DbC) :: Model every interaction between software elements as a *contract* with preconditions, postconditions and invariants.
     Contracts make correctness assumptions explicit and executable.

     #+begin_quote
     “…an explicit roster of mutual obligations and benefits, the contract.” [cite:@OOSC p. 331]
     #+end_quote

     In HTTPico we interpret HTTP methods and status codes as Eiffel contracts on resource access:
     a precondition violation corresponds to a 4xx client error;
     a broken postcondition corresponds to a 5xx server error.

- Command–Query Separation (CQS) :: Every routine should be *either* a command (may change state, returns no result) *or* a query (returns a result, causes no abstract side effects).

     #+begin_quote
     “Functions should not produce abstract side effects.” [cite:@OOSC p. 751]
     #+end_quote

     This aligns with HTTP’s distinction between safe and unsafe methods:
     in HTTPico, query-like operations correspond to safe, idempotent accessors,
     while state-changing operations correspond to commands.

- Uniform Access Principle (UAP) :: Clients must see a *single, uniform* view of access to features of a class,
     whether they are implemented via stored attributes or computed functions.
     UAP allows implementations to change representation or computation strategies without impacting clients.
     HTTPico extends this spirit from “features of one object” to “resources of a program”:
     whether a resource lives in memory, in a file, or behind an HTTP call is hidden behind a uniform protocol.

- Open–Closed Principle (OCP) :: Software elements should be *open for extension* but *closed for modification*.
     In Eiffel this is realized via inheritance, redeclaration, and dynamic binding.
     In HTTPico, OCP motivates an architecture where new stores and storage combinators can be added
      e.g., new caches, loggers, or protocol adapters, without modifying existing clients.

- Systematic Naming Principle (SNP) :: Libraries should use a consistent, systematic naming vocabulary for similar operations across different data structures [cite:@MeyerEiffelbase].
     EiffelBase uses names such as =item=, =put=, =extend= consistently across lists, stacks, queues, etc.
     This makes the library feel like one coherent design rather than a collection of unrelated pieces.
     HTTPico follows this example: all stores expose the same small set of operations,
     and scheme clients share a common naming scheme, echoing HTTP’s uniform interface.

These principles make Eiffel a natural host for an in-process REST architecture: contracts provide a home for HTTP’s pre/postcondition vocabulary; UAP and SNP support uniform access to heterogeneous resources; OCP and combinators make it easy to extend the architecture without breaking existing code.

** HTTP concepts and Eiffel principles correspondence

HTTP and Eiffel are philosophically aligned: HTTP is a protocol designed around uniform interfaces, explicit outcomes, and composable intermediaries; Eiffel is a language designed around explicit contracts, uniform access, and systematic naming. HTTPico, implemented in Eiffel, is thus a natural way to “shrink” HTTP’s architectural mechanisms into a single program.

Table [[tbl:http-eiffel-correspondence]] summarizes this alignment.

#+name: tbl:http-eiffel-correspondence
#+caption: Correspondence between Eiffel principles and HTTP architectural concepts.
| Eiffel principle | HTTP elements                                     | Correspondence / Comment                                                                    |
|------------------+---------------------------------------------------+---------------------------------------------------------------------------------------------|
| DbC              | Methods, status codes                             | Both provide a vocabulary for contracts and failures on operations.                         |
| CQS              | Safe/unsafe, idempotent methods                   | Queries correspond to safe, idempotent methods; commands to state changes.                  |
| UAP              | URIs and uniform interface                        | Both hide representation and location behind a uniform access mechanism.                    |
| OCP              | Proxies, caches, middleware/intermediaries        | Both architectures favor inserting new intermediaries without changing clients and servers. |
| SNP              | Method names, status code families, URI structure | Coherent naming and classification make APIs and architectures easier to learn and compose. |

In the rest of the paper we make this correspondence concrete: HTTPico defines Eiffel classes for polymorphic identifiers, stores, and storage combinators that bring HTTP’s architectural style into a statically typed, contract-based setting.



* Implementation

** HTTP URIs become URI_PYM

To support polymorphic identifiers in Eiffel, we first need a solid representation of URLs/URIs *inside* the program.
Fortunately we do not have to re-implement URL parsing from scratch: EiffelStudio already ships with a =URI= library that understands the standard components of a URI.

For reference, a URI can be decomposed as follows:

(modified from a parsing diagram by Steven Levithan and the WHATWG URL specification.)

In HTTPico we reuse Eiffel’s =URI= class and extend it into =URI_PYM=.
The goal of =URI_PYM= is **not** to change the syntax of URIs, but to make URIs *more convenient as polymorphic identifiers*:

- we add conversion routines to turn a =URI_PYM= into scheme-specific helper types (e.g., =FILE_URL=, =ENV_URL=, =HTTP_URL=);
- we provide queries that expose the path as a sequence of segments, which we later reuse as keys for stores;
- we keep the representation immutable, so that a URI safely identifies the same resource throughout its lifetime.

The Eiffel implementation is a thin wrapper around =URI=;
the interesting behavior comes later, when we plug =URI_PYM= into scheme handlers and stores.

Here is the listing

#+results:
;; (Generated short view of class URI_PYM, omitted here.)


** HTTP Request become HTTPICO_VERBS

Once URIs are available as =URI_PYM= objects, we need an in-process equivalent of HTTP methods.
In Weiher’s work this is the =Storage= protocol;
in HTTPico it is a deferred Eiffel class we call =HTTPICO_VERBS=,
which provides the core “HTTP-like” operations for in-process REST.

We deliberately design this interface to resemble both:

- the HTTP method vocabulary (GET, HEAD, PUT, POST, DELETE, etc.), and
- Eiffel’s =HASH_TABLE= protocol, so that stores feel as familiar as ordinary tables.

#+begin_src bash
ec -config ./restful.cfg -short HTTPICO_VERBS
#+end_src
;; (Generated short view of class HTTPICO_VERBS, omitted here.)


Several points are worth noting:

- Weiher’s original interface is named =Storage= and expressed as an Objective-S protocol.
  In our Eiffel implementation we call the deferred class =HTTPICO_VERBS=,
  because EiffelBase already uses the names =STORAGE= and =STORE= for different purposes.
- The interface is **inspired** by HTTP methods, but follows the *shape* of a hash table:
  queries such as =has_item= and =item= correspond to safe, idempotent access (HEAD/GET),
  and commands such as =expand= and =force= correspond to state-changing operations (POST/PUT).
- This connection to =HASH_TABLE= is intentional and mirrors Weiher’s decision to align with the =NSDictionary= protocol in Objective-C:
  instead of inventing a new dictionary-like API,
  we reuse the vocabulary that Eiffel programmers already know.

Conceptually, =HTTPICO_VERBS= offers:

- a family of *queries* that do not change state (GET/HEAD-like),
- a family of *commands* that change state (PUT/POST/PATCH/DELETE-like),
- and Eiffel contracts that make success and failure conditions explicit
  (preconditions and postconditions instead of raw status codes).

This interface will be the common backbone shared by all scheme handlers and storage combinators.


A =HTTPICO_SCHEME_HANDLER= is a subclass that tries to preserve HTTP semantics more strictly:
it interprets safe vs. unsafe and idempotent vs. non-idempotent operations in a way that closely matches their HTTP counterparts. In the rest of this section, we always expose our in-process storage through this small, HTTP-inspired API.


** HTTPICO_SCHEME_HANDLERs

In practice, URIs can use many schemes: =http=, =https=, =file=, =env=, =ftp=, and so on.
For each scheme we need a component that understands how to *talk* to the corresponding origin:
open files, read environment variables, issue HTTP requests, etc.

A =SCHEME_HANDLER= is such a component:
a class that knows how to communicate with a server for a given scheme and that exposes the common HTTPico request interface.

In HTTPico, a scheme handler has two important properties:

1. It is always defined *with respect to* a base URL.
   This mirrors the browser notion of a “current origin”.
2. It respects the common interface defined by =HTTPICO_VERBS= (our HTTP-like query/command protocol),
   so that other components can treat handlers uniformly.

*** Deferred SCHEME_HANDLER

We start from an abstract scheme handler that captures what all handlers have in common.
Conceptually, a handler manages one or more schemes (e.g., =http= and =https= together) and can manufacture concrete handler objects for specific base URIs.

A simplified version looks like this:

#+begin_src eiffel
deferred class RAW_SCHEMA_HANDLER

feature -- Supported schemes

  my_schemas: LIST [STRING]
      -- Schemes handled by this class (e.g., <<"http", "https">>)

feature -- Factory

  for (a_url: URL): like Current
      -- Return a handler instance suitable for `a_url`.
    require
      url_must_be_for_my_schema: a_url.schema ∈ my_schemas
    deferred
      -- In descendants: create Result and attach it to `a_url` as base.
    end

feature {NONE} -- Creation details

  -- ... hidden creation routines ...

end
#+end_src

This class does not yet know *how* to talk to HTTP, files, or the environment;
it only specifies the **contract**: given a URL whose scheme belongs to =my_schemas=,
you can obtain a handler that will later support the HTTPico request methods for that URL.

*** How we handle different schemas?

Each concrete scheme handler faces the same tension:

- it is specific to a given scheme (or small set of schemes),
- but it must expose the **same** request interface so that higher-level components can remain generic.

HTTP gives us a ready-made answer: its method vocabulary.
We therefore define an abstract =SCHEMA_HANDLER= that:

- fixes the schema (or schemas) it is responsible for,
- stores a base path (origin) to which relative paths are resolved,
- and declares a set of HTTP-inspired queries and commands.

In Eiffel this is a deferred class, parameterized by the representation type =R=:

#+begin_src eiffel
deferred class SCHEMA_HANDLER [R]

feature -- Schema identification

  schema: IMMUTABLE_STRING
      -- Primary scheme handled by this class (e.g., "http")

feature -- Connection state

  base_path: URL
      -- Base URL for resolving relative paths.

  connect (a_base_path: URL)
      -- Attach this handler to `a_base_path`.
    require
      same_schema: a_base_path.schema ~ schema
    deferred
      -- Descendants set `base_path := a_base_path`.
    end

feature -- HTTP-inspired queries

  has_item (key: PATH): BOOLEAN
      -- Equivalent of HTTP HEAD: does resource for `key` exist?
    deferred
    end

  item (key: PATH): R
      -- Equivalent of HTTP GET: obtain representation for `key`.
    deferred
    end

feature -- HTTP-inspired commands

  expand (data: R; key: PATH)
      -- Equivalent of HTTP POST: add or extend resource at `key`.
    deferred
    end

  force (data: R; key: PATH)
      -- Equivalent of HTTP PUT: create or replace resource at `key`.
    deferred
    end

  -- Additional operations (merge, delete, etc.) can be added as needed.

end
#+end_src

Descendants of =SCHEMA_HANDLER= implement these operations in a scheme-specific way
(e.g., using file I/O, environment variables, or HTTP client libraries),
but clients always see the same small, HTTP-inspired protocol.

**** How does an Env handler look?

An =env://= handler treats the process environment as a simple key–value store.
Keys correspond to variable names; values are strings returned by the operating system.

Conceptually, an environment handler might look like this:

#+begin_src eiffel
class ENV_HANDLER
inherit
  SCHEMA_HANDLER [STRING]
    redefine
      schema, has_item, item, expand, force
    end

feature -- Schema identification

  schema: IMMUTABLE_STRING = "env"

feature -- HTTP-inspired queries

  has_item (key: PATH): BOOLEAN
      -- Is there an environment variable with this name?
    do
      Result := os_has_environment_variable (key.to_string_8)
    end

  item (key: PATH): STRING
      -- Get the value of the environment variable.
    do
      Result := os_environment_variable (key.to_string_8)
    ensure
      defined_implies_not_void: has_item (key) implies Result /= Void
    end

feature -- HTTP-inspired commands

  expand (data: STRING; key: PATH)
      -- Set an environment variable (where the OS allows it).
    do
      os_set_environment_variable (key.to_string_8, data)
    end

  force (data: STRING; key: PATH)
      -- Same as `expand` for this simple store.
    do
      expand (data, key)
    end

end
#+end_src

The details (which OS calls to use, how to represent =PATH=) are implementation-specific,
but the key point is that =env://= URIs now participate in the same in-process REST protocol as HTTP and file resources.

**** How does a file:// handler look?

A =file://= handler uses the local filesystem as its backing store.
To keep the URI semantics explicit, we first introduce a =FILE_URL= type as a specialization of =URL=:

#+begin_src eiffel
class FILE_URL
    -- A file URL is a URL whose scheme is "file".
inherit
  URL
    -- Inherit parsing and access to components.
  -- ...

invariant
  schema_must_be_file: schema ~ "file"
end
#+end_src

The handler then maps file URIs to actual file operations:

#+begin_src eiffel
class FILE_HANDLER [R]
inherit
  SCHEMA_HANDLER [R]
    redefine
      schema, has_item, item, expand, force
    end

feature -- Schema identification

  schema: IMMUTABLE_STRING = "file"

feature -- HTTP-inspired queries

  has_item (key: PATH): BOOLEAN
      -- Does the file designated by `key` exist?
    do
      Result := file_exists (to_file_url (key))
    end

  item (key: PATH): R
      -- Read the contents of the file designated by `key`.
    local
      f: PLAIN_TEXT_FILE
    do
      create f.make_open_read (to_file_url (key).as_string_8)
      -- In a concrete instantiation, `R` would typically be STRING or RAW_FILE.
      -- For simplicity we assume `R` can be built from the file contents.
      Result := read_representation (f)
    end

feature -- HTTP-inspired commands

  expand (data: R; key: PATH)
      -- Append or create a file (POST-like behavior).
    do
      -- ...
    end

  force (data: R; key: PATH)
      -- Overwrite or create a file (PUT-like behavior).
    do
      -- ...
    end

feature {NONE} -- Helper

  to_file_url (key: PATH): FILE_URL
      -- Build a FILE_URL from the handler's base path and `key`.
    do
      -- ...
    end

  read_representation (f: PLAIN_TEXT_FILE): R
      -- Construct a representation from file contents.
    do
      -- ...
    end

end
#+end_src

Again, the exact details are less important than the fact that the handler adheres to the same =SCHEMA_HANDLER= protocol.

**** How does an http handler look?

An HTTP handler wraps an HTTP client library and delegates HTTPico operations to real HTTP requests.
Given a base URL such as =http://api.github.com=, the handler can implement:

- =has_item= with HTTP HEAD (or GET and mapping 404 to False),
- =item= with HTTP GET,
- =expand= with POST,
- =force= with PUT or PATCH.

The core idea is that =http://= URIs are not special:
they are just another scheme handled through the same uniform interface,
whether the underlying transport is a local file,
an environment variable, or a networked HTTP service.


** HTTPICO_RESOURCES

A *resource* in HTTPico is an object that represents an **origin** that is unique within the system.
For example, there is only one GitHub service on the public Internet, reachable at =https://api.github.com=.
In the same spirit, there should be a single =GITHUB= resource object in the program.

An HTTPICO_RESOURCE (despite the name, now part of HTTPico) therefore combines:

- a canonical base URI (e.g., =https://api.github.com=),
- a suitable =SCHEME_HANDLER= (e.g., an HTTP handler),
- and possibly additional domain-specific behavior (e.g., GitHub-specific endpoints).

Instead of scattering ad-hoc HTTP client instances throughout the codebase,
we centralize access through resource objects.
This makes reasoning about caching, rate limiting, and authentication much easier,
and aligns with the idea that “anything that can be named can be a resource.”


** Web DNS became Resource Name Server

On the Web, the Domain Name System (DNS) maps human-readable names to network addresses
and helps ensure thappt “github.com” denotes the same origin for every client.
In HTTPico we need a similar mechanism *inside* the program:
a registry that maps resource names or URIs to the unique resource objects that represent them.

We call this component the =RESOURCE_NAME_SERVER=. It follows a classic Registry pattern:

- it holds a mapping from resource identifiers (strings or URIs) to resource objects;
- it guarantees that each identifier is associated with **exactly one** resource instance;
- it returns existing instances on repeated lookups instead of creating new ones.

The advantages are twofold:

- Uniqueness :: Every part of the program that talks to, say, the GitHub API, does so through the same =GITHUB=
     resource object and thus through the same underlying HTTP handler and configuration.
- Coordination :: Because access is funneled through shared resource objects,
     cross-cutting concerns such as caching, logging, authentication,
      or rate limiting can be implemented once (via storage combinators around the handler) and automatically benefit all callers.

In other words, the RESOURCE_NAME_SERVER plays the role of an *in-process DNS* for HTTPico:
it ensures that names (URIs) reliably identify the same in-process resources,
completing the mapping from Web architecture to Eiffel implementation.


* Evaluation
Now let's compare the HTTPico enhanced method to connect to a todo-mvc sever VS plain eiffel.

and also vs plain Java which is also a strongly typed language.

and Plain Javascript (which is dynamic and should be the best implementation)

* Discussion

This work started from an “analysis plus delta” mindset.
We took Weiher’s Architecture-Oriented Programming ideas and In-Process REST as the baseline,
then asked what needed to change to make them fit naturally into Eiffel and its ecosystem.
The “analysis” part is the Background and Implementation:
we reuse URIs, HTTP verbs, and storage combinators,
but we reify them in Eiffel with Design by Contract, constrained genericity, and multiple inheritance.
The “delta” is a set of design lessons that emerged while building HTTPico in practice.

In this section we summarize those lessons as a series of short guidelines,
each phrased as a reflection on what worked, what did not,
and what we would do again when porting HTTP-style architectures into another language.
** Lessons Learned

*** Inspired by HTTP but Implemented in your language

The first lesson is to treat HTTP as an *architectural source of inspiration*, not as an API to be copied verbatim.
HTTPico borrows HTTP’s structure:

- URIs as uniform names for resources,
- a small vocabulary of verbs (GET/PUT/MERGE/DELETE),
- and intermediaries (caches, loggers, switches) that are symmetric and composable.

However, the *surface* of the interface must feel native to the host language.
In Eiffel, this means that stores and scheme handlers look and behave like tables and dictionaries:
they support operations similar to `item`, `put`, and `remove`,
and they follow Eiffel’s conventions for preconditions, postconditions, and invariants,
instead of mimicking HTTP headers or status codes directly.

The general guideline is:

- keep HTTP’s *architecture* (URIs + verbs + intermediaries),
- but align the *API vocabulary* with the collections and naming style of your language.

*** state-less is natural but difficult to fake

On the Web, HTTP is intentionally stateless:
every request carries everything the server needs to know (URI, method, headers, body),
and intermediaries can forward or cache requests without inspecting hidden state.

Inside a program, however, objects and references are intrinsically stateful:
they have identity, aliased references, and lifetime rules.
Trying to blindly “fake” HTTP’s statelessness at the object level is both hard and misleading.

In HTTPico we found a better compromise:

- we keep the *API* stateless: each storage operation is expressed as “verb + URI + optional representation”;
- we hide the truly stateful parts (connection pools, file handles, authentication tokens, caches)
  behind scheme handlers and storage combinators;
- we use Eiffel contracts to express the assumptions that HTTP would encode as status codes
  (for example, “resource must exist” vs. “resource may be created”).

The lesson is that statelessness is a *boundary discipline*:
we do not try to make the entire object graph stateless,
but we preserve a stateless, uniform *resource interface* and let the scheme handlers encapsulate the stateful machinery.

*** Reuse through inheritance helps a lot

A pleasant surprise of the Eiffel version is how much we could reuse existing infrastructure.
We did not implement URL parsing, file I/O, HTTP clients, or environment-variable access from scratch.
Instead we:

- reused the existing `URI` library and wrapped it as `URI_PYM`,
- wrapped the filesystem, environment variables, and HTTP client as `SCHEME_HANDLER` descendants,
- and added the storage combinator protocol on top.

Multiple inheritance was particularly useful:
a handler can inherit both from a low-level client (e.g., HTTP or FTP) and from an abstract storage class,
then refine the few points where URIs and verbs are translated into concrete calls.

The general guideline is:

- *inherit and adapt* your platform’s libraries into the storage protocol,
  rather than replacing them with a new custom stack;
- keep the storage interface small, so inheritance trees remain simple and understandable.

*** Weiher's Fundamental Insight is brilliant.

Weiher’s fundamental insight is that the *architecture* of the Web
(URIs, a uniform verb vocabulary, and symmetric intermediaries)
is valuable even when there is no network involved.
Once we stop thinking of “HTTP” as “the thing done by web servers”,
and instead think of it as a pattern for *resource-centric composition*,
we can reuse the same architectural style inside a single program.

HTTPico confirms this insight in a different setting:

- Storage combinators in Eiffel play the same role as HTTP intermediaries:
  caches, logging layers, switching stores, asynchronous writers, etc.
- Because they all implement the same `store` protocol,
  we can chain, reorder, and replace them without changing clients.
- Eiffel’s type system and contracts ensure that these compositions respect the assumed behaviour,
  in a way that is not available in the original dynamic Objective-Smalltalk setting.

From our perspective, Architecture-Oriented Programming is not a metaphor,
but a concrete engineering method:
pick a well-understood architecture that already scales (here: HTTP/REST),
then scale it *down* into a language while preserving its composition properties.

*** Schema_handlers will be many, but resources should be unique

Another lesson concerns *identity*.
On the Web, a URL names a resource globally.
Many different HTTP servers, caches, and proxies may handle traffic for that URL,
but there is still a single, conceptual “resource at that address”.

In HTTPico this leads to a separation:

- there may be many `SCHEME_HANDLER` instances for a given scheme (e.g., several HTTP clients, multiple filesystem roots),
- but a given URI should correspond to one *logical resource* in the in-program world.

To support this, we introduced a Resource Name Server (RNS),
an in-program registry that maps URIs to resource objects.
The RNS plays a role analogous to DNS:
it ensures that different parts of the program that talk about `http://example.org/foo`
end up referring to the same logical resource, no matter which handler they use.

The design guideline is:

- let *handlers* be plentiful and configurable,
- but maintain a *single registry of resources* to preserve the intuition
  that “a URI points to one thing”.

*** Naming is really hard

Naming turned out to be a larger design issue than we anticipated.
We needed to balance several pressures:

- staying close to HTTP terminology (resources, methods, URIs),
- respecting Eiffel’s style (class names, feature names, command/query separation),
- and avoiding confusion with “real” HTTP servers, clients, and REST APIs.

Even the project name went through several iterations:
“RESTLY”, and then “HTTPym” (HTTP with Pym Particle[fn:1]), before settling on “HTTPico”.
Each name carried different connotations, and some of them risked inviting unhelpful “REST compliance” debates.

The specific lesson is less about the final choice and more about the process:

- follow the naming conventions of your host language and its base library;
- reuse existing verbs where possible (e.g., `item`, `put`, `remove` for table-like access);
- avoid overloading established HTTP terms in ways that contradict their Web meaning.

[fn:1] Pym Particle is the thing that makes Ant-man shrink in the Marvel comics.

*** The fundamental data structure is really important.

Architectures are not only made of interfaces; they rest on concrete data structures.
In HTTPico, two structures matter a lot:

- *maps/tables* for storing resource state keyed by URIs or paths,
- and *prefix trees (tries)* or hierarchical structures for organising paths and partial URIs.

A naive implementation using only flat hash tables “works”,
but quickly makes it harder to express nesting, delegation, and partial matching of paths.
Once we reintroduced a more tree-like structure for paths,
both scheme handlers and storage combinators became simpler and more regular:
prefixes correspond to mount points, and entire subtrees can be passed behind a single handler.

The guideline is:

- choose underlying data structures whose *shape* matches the architecture:
  trees for hierarchical URIs, hash tables for fast lookups, and so on;
- make those structures explicit in the implementation, instead of hiding them behind ad-hoc access patterns.

*** Maybe Resoure Name Server is not Necessary in Eiffel

Given Eiffel’s support for `once` routines and “singleton-like” patterns,
it was tempting to avoid the Resource Name Server entirely,
and to represent each resource as a separate once object:

- for each URI we could, in principle, have a dedicated class whose once feature yields the unique instance.

This approach would have eliminated a level of indirection,
but only by pushing the complexity into the *type level*:
we would need a class per resource, or at least per resource family,
and we would lose the ability to treat URIs as purely data-driven resource identifiers.

In practice, we found that:

- Eiffel’s `once` mechanism is great for global services,
  but less suited to “one instance per dynamic URI string”;
- a central RNS with a dictionary-like structure is simpler to reason about
  and matches the way DNS works on the Web.

So while Eiffel’s singleton mechanisms are attractive,
our experience suggests that an explicit name server is the better match
for HTTP-style resource identity.

** Limitations

The current version of HTTPico is intentionally modest in scope.
Several important aspects of HTTP and Weiher’s original framework are not yet covered:

- We do not do content negotiation ::
     each URI is mapped to a specific Eiffel type or representation.
     There is no notion of “same resource in JSON or XML” negotiated at runtime.
     This simplifies the type story but gives up some of HTTP’s flexibility.

- No Authentication (yet) ::
     many useful schemes (HTTP, FTP, cloud APIs) require authentication and authorisation.
     In HTTPico we currently rely on whatever the underlying libraries provide.
     We do not model authentication as part of the storage protocol,
     nor do we treat credentials as first-class resources.

- This version is single threaded ::
     the library assumes a single-threaded execution model.
     Concurrent reads and writes on the same resource, or cross-thread compositions of stores,
     are not addressed yet.
     Eiffel’s SCOOP model suggests a natural direction here,
     but we have not explored it in this paper.

- Eiffel’s constrained genericity works with “AND” constraints, not “OR” ::
     we can express “S must conform to both STORE and SERIALISABLE”,
     but not “S can be created from JSON *or* XML”.
     This leads to some awkward but explicit constructions in the type system,
     and hints at richer type support that would make polymorphic identifiers and storage combinators more expressive.

These limitations are not accidental:
they mark the boundary of what we chose to tackle in this first iteration,
and they motivate the future work we outline next.

** Future Work

This work opens several directions that we deliberately postponed.
Broadly, we see three axes of extension:

- more breadth :: more schemes, more combinators, more domains;
- *more depth :: stronger typing and better verification of compositions;
- more concurrency and distribution :: scaling HTTPico from single-threaded in-process use to IPC and true microservices.

The rest of this section sketches some of these directions.

*** HTTPmicro: Communicating concurrent objects with HTTP

One natural next step is to connect HTTPico with Eiffel’s concurrency model.
If we treat each resource (or each scheme handler) as a separate SCOOP processor,
then HTTP-style messages become a *concurrency API*:

- each “request” is a call to a separate object,
- intermediaries (caches, loggers, switches) can be placed between processors,
- and URIs give us a uniform addressing scheme for concurrent objects.

Under the name “HTTPmicro” we imagine a layer where concurrent objects talk to each other
using the same URI + verb protocol used inside HTTPico,
so that in-process concurrency and the storage architecture remain aligned.

*** HTTPnano: Inter Process Communication (IPC) with HTTP

A second step is to cross the process boundary while keeping the same architectural core.
“HTTPnano” is our working label for an IPC-oriented variant of HTTPico,
where the same storage protocol is implemented:

- over local IPC mechanisms (pipes, Unix domain sockets, shared memory),
- or over loopback HTTP servers that serve only as a transport.

The goal is not to re-implement a full web server,
but to preserve the illusion that “all communication is via URIs and verbs”,
even when part of the system lives in another process.

**** in the 3rd paper we will make the system Concurrent with SCOOP

Concurrency deserves its own treatment,
and we do not attempt to solve it fully in this paper.
A follow-up paper will focus on:

- mapping HTTPico resources and scheme handlers to SCOOP processors,
- expressing concurrency assumptions in contracts,
- and showing how storage combinators behave under contention (e.g., concurrent caches and loggers).

We mention this here only to mark the path:
the present work is the single-threaded foundation on which that future system can be built.

*** HTTPmicro: Distributed systems

Finally, the architecture can be scaled *back up* to genuine distributed systems.
Once HTTPico has a clear story for concurrent and IPC-level communication,
it becomes natural to reconnect it to “real” HTTP:

- some URIs will be served by in-process handlers,
- some by local IPC bridges,
- and some by actual web services over the network.

At that point “HTTPmicro” can be read in a more conventional way:
as a family of microservices whose internal structure is still governed by the HTTPico storage protocol.
The hope is that by using the same architecture from objects, to processes, to services,
we can reduce the mental gap between “in here” and “out there”:
the same ideas about URIs, verbs, and intermediaries apply at all scales.



* Related Work
HTTPico is directly inspired by Marcel P. Weiher’s work on
Architecture-Oriented Programming (AOP), Polymorphic Identifiers, and Storage Combinators
[cite:@WeiherPolymorphicIdentifiers;@WeiherStorageCombinators;@WeiherInProcessRest].
In Objective-Smalltalk, Weiher shows how to scale the Web’s architecture down into a single process:
URIs become polymorphic identifiers,
HTTP’s uniform interface becomes a small storage protocol,
and HTTP intermediaries (proxies, gateways, caches) inspire composable “storage combinators”.

That work demonstrates the feasibility and expressiveness of in-process REST,
but it is developed in a dynamic, untyped, Smalltalk-like setting with relatively lightweight contracts.
HTTPico revisits the same architectural ideas in a **statically typed, contract-based** environment (Eiffel),
and explores what changes when polymorphic identifiers and storage combinators are expressed with
Design by Contract, constrained genericity, and multiple inheritance.

** Differences with Weihers AOP
Weiher’s AOP framework and HTTPico share the same architectural core:
resources are addressed by URIs, manipulated through a small vocabulary of verbs,
and composed via intermediaries that behave like storage combinators.
The main differences lie in the host environment and the goals of the experiment.

In Objective-Smalltalk, the storage protocol is integrated into a dynamic, message-based language:
the protocol is largely “by convention” (e.g., `NSDictionary`-style access),
and type and contract checks are informal or ad-hoc.
This makes experimentation extremely flexible and has enabled Weiher’s library to evolve over more than a decade.

In HTTPico, the same architectural elements are reified as Eiffel classes and interfaces.
The storage protocol is captured explicitly in the type system,
and contracts state the preconditions and postconditions for each operation.
This move from convention to explicit protocol is the main “delta” between Weiher’s AOP and HTTPico:
we keep the AOP architecture, but we ask how far static typing and contracts can take it.

** Statically typed Stores
HTTPico takes Weiher’s ideas into a **statically typed, contract-based** environment.

We keep the core AOP insight—shrinking HTTP’s uniform interface into a program—
but we reify it in Eiffel, mapping HTTP methods and status codes to Eiffel’s Design by Contract,
and using multiple inheritance and constrained genericity to type-check compositions
of scheme handlers and intermediaries.

In contrast to Objective-Smalltalk, where the storage protocol follows Objective-C’s `NSDictionary`
“by convention”, HTTPico embeds the protocol in Eiffel’s type system:
stores, resources, and scheme handlers have explicit generic parameters,
and pre- and postconditions express the expectations between clients and suppliers.
This makes violations visible as contract failures rather than as ad-hoc status checks,
and it allows static analysis tools (and human readers) to reason about compositions.

** Statically typed Storage Combinators
In his work on Storage Combinators, Weiher explicitly identifies strong typing as a direction for future work
[cite:@WeiherStorageCombinators], but he is sceptical that existing type systems would be flexible enough:

#+begin_quote
Maybe no strong type system is flexible enough,
since storage combinators represent such varied data.
#+end_quote

HTTPico explores this question in Eiffel rather than designing a bespoke type system.
Eiffel’s type system combines:

- single and multiple inheritance,
- constrained genericity,
- and explicit conversion (instead of unchecked casting),

which makes it possible to express combinators whose types are *compositions* of multiple roles.
For example, a storage combinator can be constrained to accept only resources that are both
serialisable and retrievable, or only handlers that support a given subset of verbs.

While this does not fully solve the problem of “typing all possible combinators”,
it shows that a mainstream, contract-based OO language can go further than expected:
many useful compositions can be expressed and checked without abandoning a general-purpose type system.

** Objective-S is more user friendly
Objective-S is Weiher’s programming language that integrates these architectural ideas directly into the language.
This makes many things more user friendly than in HTTPico:
URI literals, polymorphic identifiers, and storage combinators have dedicated syntax and are part of the core language,
rather than living in a library.

HTTPico, by contrast, is “just” a library in Eiffel.
As a result, it relies more heavily on the programmer understanding and correctly applying the storage protocol.
There is no special syntax for URIs or combinators; they are ordinary Eiffel objects and features.

We do not view this as a disadvantage, but as a complementary design point:
Objective-S explores what happens when AOP becomes a *language*,
while HTTPico explores what happens when the same ideas are embedded as a reusable *library*
into a strongly typed, contract-based environment.

** Storage Combinator library is more diverse and mature
Weiher’s Storage Combinator library is very mature.
The ideas have been refined for over 15 years,
and the library includes a wide and deep collection of combinators and handlers ready to use:
caches, loggers, content filters, routing combinators, and many more.

In contrast, HTTPico is young and intentionally narrow.
At the time of writing, it includes only a small set of `SCHEME_HANDLER` classes
(for example, a file-based handler, an environment-variable handler, and an HTTP handler),
and a single caching storage combinator.
Even in the planned follow-up work, the focus remains on concurrency and architectural questions
rather than on quickly matching the breadth of Weiher’s library.

The comparison is therefore asymmetrical:
HTTPico is not a competitor to the existing Storage Combinator ecosystem,
but an experiment in how far those ideas can be carried in Eiffel.

** HTTP and REST-inspired abstractions in programming languages
Mainstream languages provide HTTP client libraries and “REST frameworks”
that expose HTTP verbs at the API level (e.g., `get`, `post`, `put`)
and often model resources as routes or controller methods.
These libraries treat HTTP primarily as an **I/O protocol** for talking to remote web servers.
They rarely extend the HTTP model to local or in-process resources:
databases, configuration files, and internal dictionaries usually keep their own ad-hoc APIs,
and composition between them is done manually with bespoke glue code.

HTTPico is different in two ways.

First, it treats HTTP’s architectural elements—URIs, methods, status-like outcomes—not only as I/O concerns,
but as **first-class design abstractions inside a program**:
they govern how in-process resources are named, accessed, and composed.

Second, it applies that architectural pattern uniformly across heterogeneous schemes:
`env://`, `file://`, and `http://` all expose the same HTTPico protocol inside Eiffel.
This is closer to Weiher’s AOP vision than to traditional HTTP client libraries,
and it explicitly targets in-process modularity and composability,
rather than “just” building web services.

To the best of our knowledge, apart from Weiher’s Objective-Smalltalk framework,
there is no widely used library that combines polymorphic identifiers, storage combinators,
and a uniform verb vocabulary in this way.

** Uniform resource access, URI abstractions, and Eiffel libraries
There is also a long history of “uniform resource access” mechanisms,
such as virtual file systems and “everything is a file” interfaces,
that expose heterogeneous resources behind a common API.
These systems typically generalise the POSIX file API (paths, `open`, `read`, `write`)
rather than HTTP’s uniform interface,
and they operate at the operating-system or filesystem level
rather than at the level of in-process architectural constructs.
They offer uniform naming and access, but without HTTP’s distinction between safe/unsafe or idempotent methods,
or the explicit contract outcomes (status codes) that HTTP provides.

Within Eiffel, existing web frameworks and libraries
(such as EiffelWeb / EWF, and URI and HTTP client classes in EiffelBase)
provide support for building web servers and clients,
and already include reusable abstractions for URLs and paths.
HTTPico builds on these foundations: it reuses existing URI and filesystem classes,
but constrains and composes them through a REST-like in-process protocol (the HTTPico request methods),
typed scheme handlers, and storage combinators.

There is no previous Eiffel library that integrates HTTP’s architectural style,
Design by Contract, and Weiher’s AOP ideas into a single, coherent in-process framework
for accessing heterogeneous resources.



* Conclusion

HTTPico started from a simple question:
what happens if we shrink the Web’s HTTP architecture into a single Eiffel program,
instead of treating HTTP as something that only happens “out there” on the network?
Following Weiher’s Architecture-Oriented Programming and In-Process REST,
we treated URIs, a small set of verbs, and composable intermediaries as first-class architectural elements,
and then re-expressed them in Eiffel using Design by Contract, constrained genericity, and multiple inheritance.

The result is not a new web framework,
but a small in-process architecture for accessing heterogeneous resources in a uniform way.
URIs become polymorphic identifiers for in-program resources.
Scheme handlers encapsulate the concrete mechanisms for `env://`, `file://`, and `http://` access,
while exposing a common storage protocol.
A Resource Name Server (RNS) keeps the intuition that “a URI points to one thing” even when several handlers and intermediaries may be involved.
Eiffel’s contracts turn HTTP’s implicit assumptions and status codes into explicit preconditions and postconditions,
so protocol violations become contract failures instead of ad-hoc error codes.

From an “analysis plus delta” perspective, HTTPico confirms much of Weiher’s original insight and adds a different angle.
The analysis is that the architecture of HTTP—uniform interface, intermediaries, resource-centric composition—remains valuable even without a network.
The delta is that a statically typed, contract-based language can host these ideas in a way that is both expressive and disciplined.
Typed scheme handlers and storage combinators show that we can go further with an existing general-purpose type system than Weiher initially expected,
even if we do not claim to have “typed all possible combinators”.

At the same time, this first version of HTTPico is deliberately modest.
We do not yet address content negotiation, authentication as a first-class concern, or concurrency.
The current library is single-threaded, focuses on a handful of schemes,
and explores only a small subset of the possible storage combinators.
These are not flaws of the approach, but boundaries of the experiment:
they mark what we chose to explore in this paper and what remains future work.

That future work is already sketched. On the in-process side, HTTPmicro would use the same URI-and-verb protocol as a concurrency API over SCOOP processors,
turning resources and scheme handlers into communicating concurrent objects.
On the inter-process side, HTTPnano would reuse the HTTPico storage protocol over IPC mechanisms and lightweight HTTP bridges,
before reconnecting to “real” HTTP services in a distributed HTTPmicro setting.
Across these scales, the goal is the same: to reuse an architecture that already works at Web scale,
and to keep its composition principles intact as we shrink it into programs and then scale it back out again.

The main contribution of HTTPico is therefore not a particular API, but a demonstration:
that shrinking big systems that work is a viable, productive way to design modular software.
By embedding the HTTP architecture inside Eiffel, HTTPico shows how URIs, verbs, intermediaries,
and contracts can work together as a uniform resource layer for ordinary programs,
and how Architecture-Oriented Programming can be made precise in a typed, contract-based setting.
